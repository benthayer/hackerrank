These are my solution attempts for the Determining DNA Health problem
https://www.hackerrank.com/challenges/determining-dna-health/problem

I was the 357th person to solve this problem.

In this problem, you are meant to determine the health of a sequence of DNA. You are given a list of gene sequences and their corresponding health values. Your are then given several sequences of DNA. For each sequence, you are also given 2 numbers denoting the start and end indices corresponding to a range of gene sequences and related health values that you need to account for. The final output is simply the minimum and maximum health values of all the genes that were tested.

Since repeat Genes are allowed, I parsed all the genes and stored their indices and health values in a list. For each DNA sequence, I would iterate though the characters and lengths to produce every substring. I noticed that some of the Gene lengths were long and there were none of intermediate length, so I also keep a list of the lengths of genes to reduce the number of substrings necessary to compute. For each substring, I used a std::map to find the relevant gene. Each Gene has a method that gets the sum of the health values given the range of elements that are to be counted for the health. I called this for each Gene and returned the sum. This solved a few test cases, but timed out on many. This solution is saved in main_v0.cpp

To increase efficiency, in main_v1.cpp, I switched from using a map to using a 26-ary tree for more efficiant lookups. Each branch represented a character in the substring and when there was no gene for a given substring, the tree would cut off, allowing character by character comparison and faster cutoffs for lookups that would return null. This solved all test cases except 13 and 14, which timed out.

Test cases 13 and 14 both had a very small character set. Test case 13 can be found in the testcases directory. a, b, c and d are the only characters used in test case 13 and many of the genes are fairly small, meaning that there were many repeats. I exploit this structure by saving the indexes in a binary tree whose leaf nodes contain the cumulative health of all indexes of that gene. The health in a range is calculated by finding the corresponding leaf nodes and subtracting. The genes that were 2 long had around 750 instances, 3 long had around 200 each. Since these genes are also the most common substrings, the reduction of 750 to log_2(750)=9.5 and 200 to log_2(200)=7.6 resulted in a speedup of 6x from 25s to 4.1s for the test suite on my machine, enough to pass test cases 13 and 14 and solve the challenge.