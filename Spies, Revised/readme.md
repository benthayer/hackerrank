Here is my solution to the "Spies, Revised" problem on hackerrank
https://www.hackerrank.com/challenges/spies-revised/problem

I first used backtracking with a single thread and was able to find a solution for n=103. After adding threading, I was able to find a solution for n=213, but after that, the next rank on the leaderboard would require me to solve for n=353 and backtracking took too much time. After that, I implemented the minconflicts algorithm to hill-climb for a solution to this puzzle and was able to obtain solutions for much higher n. The maximum score for the challenge is 99.9, corresponding to n=999. I was the 83rd person to do this. Additionally, in this directory, I have included the solution for n=2001. Have fun writing a program to verify that though, I was just using the hackerrank system to verify for n<=999 and just assume that this one is also correct. ;)

For my backtracking solution, I maintain a state as can be seen in the Solver class. It keeps track of what is currently being tested and how to backtrack if a path is found to be a dead end. When expanding the next layer, I always choose the column that has the fewest possibilities, which reduces the branching factor, and is closest to the center, which blocks the maximum number of spaces available for future expansions. I also sort the list of rows in order of closest to center to furthes before testing for the same reason. When invalidating certain spots, I maintain a list of which spots have been invalidated, so that they can be revalidated later on. I also only iterate though the columns that have not yet been expanded since a column that has been expanded will not be considered again for expansion. In main_threads, one thread is created for each position choice, however this is not much faster since the solution space is relatively dense and each thread is working towards a different solution. main_betterthreads tries to alleiviate this problem by creating threads that work on smaller parts of the problem, however the solution isn't perfect because some sets of parameters lead to more possibilities, therefore making some threads take much longer to execute than others, even with similar initial parameters. I may work on a more efficient thread dispatch scheme, however minconflict produces better results than backtracking, so it would be unneccessary for the purpose of this challenge.

My solution using min-conflicts uses a very similar structure to the one using backtracking, but uses some different data structures because the program needs to maintain a complete state at all times rather than a partial state. The data structures can be found in the Solver class, otherwise, I implement the min-conflicts algorithm by the book(actually wikipedia) by selecting one of the rows that has a conflict and choosing a position for it that has fewer conflicts. Eventually, this reaches a valid solution and returns it.